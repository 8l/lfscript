#!/bin/bash

# Linux From SCRIPT - Build a Linux operating system from sourcecode
# Copyright (C) 2007-2014 Marcel van den Boer
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
#             h t t p : / / w w w . l f s c r i p t . o r g

# Error handling, subshells should inherit the handler.
trap handleErrors ERR
trap manualAbort  INT
set -E

handleErrors() {
  local EXITSTATUS="$?"

  if [ "${ERRPAUSE}" == "pause" ]; then
    ERRORSFOUND="yes"

    # Print a marker to the log, to make it easier
    # to spot WHERE an error occurs...
    echo -e "\n    *** BUILD_PROBLEM_DETECTED ***\n"
  else
    if [ "${EXITSTATUS}" == "126" ]; then
      displayMsg ERR "UNEXPECTED PERMISSION ERROR"
      displayMsg ERR "A command could not be executed. Most likely you are"
      displayMsg ERR "running this program from within a directory which is not"
      displayMsg ERR "publicly available."
    else
      displayMsg ERR "UNEXPECTED ERROR OCCURED"
      displayMsg ERR "A command stopped with exit status: ${EXITSTATUS}"
    fi

    queryAbort
  fi
}

queryAbort() {
  if [ -r "/sources/buildmgr/autoabort" ]; then
    TMP_AUTOABORT="$(cat /sources/buildmgr/autoabort)"
  fi

  if [ "${TMP_AUTOABORT}" == "1" ]; then
    displayMsg KEY WARN "-A switch used; Automatically aborting..."
    manualAbort
  else
    displayMsg KEY WARN "Press 'CTRL+C' to abort, or 'ENTER' to continue..."
    read PRESSENTER
  fi
}

# Pause error handling for later
delayErrors() {
  ERRPAUSE="pause"
}

# Stop pausing errors
handleErrorsNow() {
  if [ "${ERRORSFOUND}" == "yes" ]; then
    displayMsg ERR "Errors were detected while ${1}."
    queryAbort
  fi

  ERRORSFOUND="no"
  ERRPAUSE="resume"
}

manualAbort() {
  if [ -w "/sources/buildmgr" ]; then
    touch /sources/buildmgr/abort
    chmod 666 /sources/buildmgr/abort
  fi
  exitCleanup
  exit
}

exitCleanup() {
  # Before cleaning, ensure we're not in a limited environment.
  if [ ! -e "/buildmgr.root" ]; then
    if [ "$(whoami)" == "root" ]; then

      if [ -e "/sources/buildmgr/cleanexit" ]; then
        displayMsg KEY "Restoring environment for next package..."
      else
        displayMsg KEY ERR "Aborting..."
      fi

      if [ -r "/sources" ]; then
        displayMsg "... Restoring system state."

        # Run last (cleanup) function from the base system
        eval ${ROOTVARIABLE}="$(cat /sources/buildmgr/rootvar)"
        buildbase${LASTFUNCTION} &> /dev/null || echo -n ''

        cleanUp
      fi
    fi
  fi
}

cleanUp() {
  # Check if after cleanup, execution should continue
  if [ -e "/sources/buildmgr/cleanexit" ]; then
    local NEXTRUN="1"
  else
    local NEXTRUN="0"
  fi

  # Save new packages
  if [ -r /sources/buildmgr/newpackages ]; then
    displayMsg "... Saving newly created package archives."
    cd /sources/buildmgr/newpackages
    cp -R * "$(cat /sources/buildmgr/packsdir)" 2> /dev/null || echo -n ''
  fi

  # Copy logs
  displayMsg "... Saving logs."
  cd /sources/buildmgr/logs
  mv * "$(cat /sources/buildmgr/logsdir)" 2> /dev/null || echo -n ''

  # Remove the build user, the temporary build directory and symlinks.
  displayMsg "... Removing temporary directories."
  userdel -r ${BUILDUSER} 2> /dev/null || echo -n ''

  local FROOT="$(cat /sources/buildmgr/rootvar)"
  local SECINSTDIR="$(cat /sources/buildmgr/secinstalldir)"

  # Remove temporary directories in chroot environment
  cd /
  umount "${FROOT}/sources/buildmgr/packages" 2> /dev/null || echo -n ""
  umount "${FROOT}/sources/src"               2> /dev/null || echo -n ""
  umount "${FROOT}/sources"                   2> /dev/null || echo -n ""
  umount "${FROOT}/tools"                     2> /dev/null || echo -n ""

# FIXME: If LFScript is aborted during 'mksquashfs' (buildiso), the cleanup
#        does not unmount the fs image, and tries to delete read-only contents.
#        Hundreds of error message ensue.

  rm -rf "${FROOT}/tools"
  rm -rf "${FROOT}/sources"
  rm -rf "${FROOT}/buildmgr.root"

  if [ "${SECINSTDIR}" != "" ]; then
    rm -rf "${SECINSTDIR}"
  fi

  # Remove (links to) the chroot environment
  rm -rf "${FROOT}.2"
  rm -rf "${FROOT}"
  rm -rf /tools
  rm -rf /sources

  # If in 'clean' mode, start the next round.
  if [ "${NEXTRUN}" == "1" ]; then
    cd "${STARTDIR}"
    displayMsg KEY "Starting next round."
    deployScripts
  fi
}

# Used to print status information
displayMsg() {
  if [ "${1}" == "ART" ]; then
    local prefix=""
    shift
  else
    local prefix="(fblu)[$(date -u +%y-%m-%d/%H:%M) UTC](ret) "
  fi

  if [ "${1}" == "KEY" ]; then
    echo "" 1>&2
    shift
  fi

  if [ "${1}" == "ERR" ]; then
    local prefix="${prefix}(fwhi)(bred)"
    shift
  elif [ "${1}" == "WARN" ]; then
    local prefix="${prefix}(fyel)(bblu)"
    shift
  fi

  local MSG=$(echo -e "${prefix}$@(ret)" | sed '
    s@(fbla)@\\033[1;30m@g;
    s@(fred)@\\033[1;31m@g;
    s@(fgre)@\\033[1;32m@g;
    s@(fyel)@\\033[1;33m@g;
    s@(fblu)@\\033[1;34m@g;
    s@(fpur)@\\033[1;35m@g;
    s@(fcya)@\\033[1;36m@g;
    s@(fwhi)@\\033[1;37m@g;
    s@(bbla)@\\033[40m@g;
    s@(bred)@\\033[41m@g;
    s@(bgre)@\\033[42m@g;
    s@(byel)@\\033[43m@g;
    s@(bblu)@\\033[44m@g;
    s@(bpur)@\\033[45m@g;
    s@(bcya)@\\033[46m@g;
    s@(bwhi)@\\033[47m@g;
    s@(ret)@\\033[0m@g')

  echo -e "${MSG}" 1>&2
}

# The header for the start of the application.
topBanner() {
  local UNAME_M="$(uname -m)"

  # Baby Tux plate
  local t0="    ___    "
  local t1="   /   \   "
  local t2="  |  O_O|  "
  local t3="  \__(-)/  "
  local t4="  /(   )\  "
  local t5=" / \> </ \ "
  local t6=" \_/---\_/ "
  local ts="           "

  # Versioned logo plate
  local v0="(bbla)(bbla)(bbla)                                           "
  local v1="  (fblu)LINUX (fred)FROM SCRIPT (fyel)4         #2014-08-31  "
  local v2="(bbla)(bbla)  Copyright 2010-2014 Marcel van den Boer(fwhi)  "
  local v3="(bbla)(bbla)(bbla)                                           "

  # Website plate
  local c0="                    "
  local c1="       visit:       "
  local c2="  www.lfscript.org  "
  local c3="                    "

  # Legal plate
  local l0="                                                                 "
  local l1="  This program comes with ABSOLUTELY NO WARRANTY.                "
  local l2="  This is free software, and you are welcome to redistribute it  "
  local l3="  under certain conditions. For details, see:                    "
  local l4="  http://www.opensource.org/licenses/mit-license.php             "
  local l5="                                                                 "

  # Basic color scheme and filler
  local a="(bblu)(fwhi)"
  local f="             "

  # Display the header
  displayMsg ART ""
  displayMsg ART "${a} ${ts} ${f}${f}${f}${f}${f}  "
  displayMsg ART "${a} ${ts} (bbla)${v0}(bblu)  (bbla)(fgre)${c0}(bblu)  "
  displayMsg ART "${a} ${t0} (bbla)${v1}(bblu)  (bbla)(fgre)${c1}(bblu)  "
  displayMsg ART "${a} ${t1} (bbla)${v2}(bblu)  (bbla)(fyel)${c2}(bblu)  "
  displayMsg ART "${a} ${t2} (bbla)${v3}(bblu)  (bbla)(fyel)${c3}(bblu)  "
  displayMsg ART "${a} ${t3} ${f}${f}${f}${f}${f}  "
  displayMsg ART "${a} ${t4} (bbla)${l0}(bblu)  "
  displayMsg ART "${a} ${t5} (bbla)${l1}(bblu)  "
  displayMsg ART "${a} ${t6} (bbla)${l2}(bblu)  "
  displayMsg ART "${a} ${ts} (bbla)${l3}(bblu)  "
  displayMsg ART "${a} ${ts} (bbla)${l4}(bblu)  "
  displayMsg ART "${a} ${ts} (bbla)${l5}(bblu)  "
  displayMsg ART "${a} ${ts} ${f}${f}${f}${f}${f}  "
  displayMsg ART "(fwhi)Target architecture: (fyel)${UNAME_M}"

  displayMsg ART ""
}

# Make the 'which' command available, even if the host system does not have it.
which() {
  type -pa "$@" | head -n 1 ; return ${PIPESTATUS[0]}
}

# Override the 'chroot' command, to automate the build process.
chroot() {
  $(which chroot) $@ /sources/buildmgr/buildmgr --resumebasebuild
}

# Override the 'exec' command, to automate the build process.
exec() {
  # If the exec creates a new session of Bash, reload this script.
  if [ "$(echo $@ | grep '/bin/bash --login +h$' || echo -n '')" != "" ]; then
    builtin exec $@ /sources/buildmgr/buildmgr --resumebasebuild
  else
    builtin exec $@
  fi
}

# Override the 'passwd' command, to avoid prompts for creating passwords.
passwd() {
  echo "${1}:secret" | chpasswd
}

# Override the 'strip' command, to avoid error messages.
strip() {
  $(which strip) $@ &> /dev/null || echo -n ''
}

# Silence wget
wget() {
  $(which wget) --no-check-certificate $@ 2> /dev/null
}

# Override the 'su' command, to automate the build process.
su() {
  local SU_USR="$(echo $@ | sed 's/- //')"
  displayMsg KEY "Changing privileges (su): Now running as user '${SU_USR}'"

  $(which su) $@ -c "/sources/buildmgr/buildmgr --resumebasebuild"

  displayMsg KEY "Restoring privileges: Now running as user '$(whoami)'"
}

# Override the 'source' command, to automate the build process..
source() {
  if [ "$(echo $@ | grep '/.bash_profile$' || echo -n '')" != "" ]; then
    echo "/sources/buildmgr/buildmgr --resumebasebuild" >> ~/.bashrc
    echo "exit"                                         >> ~/.bashrc
  fi

  . "$@"
}

lfclass() {
    case $(uname -m) in
    i?86)
        VM="vm-i386"
        ;;
    arm*)
        VM="vm-arm"
        ;;
    *)
        VM="vm-$(uname -m)"
        ;;
    esac

    LFC="lfc/build"
    if [ ! -x "${LFC}/${VM}" ]; then
        LFC="/sources/buildmgr/lfc/${VMNAME}"
        if [ ! -x "${LFC}/${VM}" ]; then
            displayMsg ERR "Could not find an LFClass binary for your CPU."
            exit 1
        fi
    fi

    ${LFC}/${VM} -cp ${LFC}/libLFClass.jar org.lfscript.ExecArbiter ${@}
}

# Load the next function in the basesystem script.
resumeBaseBuild() {
  # Update function progress
  local NEXTFUNCTION="$(( $(cat /sources/buildmgr/currentfunction) + 1 ))"
  echo "${NEXTFUNCTION}" > /sources/buildmgr/currentfunction

  # Load the base system script
  local BASESYSTEM="$(cat /sources/buildmgr/basesystem)"
  . "/sources/buildmgr/scripts/${BASESYSTEM}/buildbase.lfs"

  # If not in a chroot environment, load the rootvariable
  if [ ! -e "/buildmgr.root" ]; then
    eval ${ROOTVARIABLE}="$(cat /sources/buildmgr/rootvar)"
  fi

  # If we are at the point that a backup should be made, and we're not already
  # resuming from a backup; Create a backup of the toolchain.
  if [ "${NEXTFUNCTION}" == "${RESUMEBACKUP}" ]; then
    if [ "${TMP_BACKUP_TC}" == "1" ]; then
      displayMsg "Backing up the toolchain."
      local ROOTVARC="$(cat /sources/buildmgr/rootvar)"
      chown -R root:root ${ROOTVARC}/tools
      cd "${ROOTVARC}"
      mkdir -p "/sources/buildmgr/newpackages/${BASESYSTEM}"
      tar --xz -cf \
        "/sources/buildmgr/newpackages/${BASESYSTEM}/toolchain.bak.txz" tools
      cd "${OLDPWD}"
      TMP_BACKUP_TC="0"
    fi
  fi

  # If we are at the point that the /tools directory is about to be deleted,
  # unmount that directory (if it was mounted by using -I <dir>).
  if [ "${NEXTFUNCTION}" == "${BUILDBEYOND}" ]; then
    umount /tools 2> /dev/null || echo -n ""
  fi

  # Execute next function.
  buildbase${NEXTFUNCTION} 1> /dev/null

  # Clean up and quit, if a user has aborted.
  if [ -e "/sources/buildmgr/abort" ]; then
    exitCleanup
    exit
  fi

  # Optionally build beyond the base system after a base system has completed.
  if [ "${NEXTFUNCTION}" == "${BUILDBEYOND}" ]; then
    local BUILD_CONF="$(cat /sources/buildmgr/extrapacks)"
    for script in ${BUILD_CONF}; do
      BUILD ${script}
    done

    # Finally, if installing...
    if [ "$(cat /sources/buildmgr/installdir)" != "" ]; then

      # ...copy /etc/skel/* to /root
      if [ -d /etc/skel ]; then
        displayMsg KEY "Re-creating /root from /etc/skel..."
        rm -rf /root
        cp -R /etc/skel /root
        chmod 0750 /root
        chown -R root:root /root
      fi

      # ...run the post installation scripts
      displayMsg KEY "Running remaining post-installation scripts."

      if [ -r "/sources/buildmgr/scripts/install.conf" ]; then
        . /sources/buildmgr/scripts/install.conf
      fi

      local PDIR="/sources/buildmgr/postinst"
      for p in $(ls -1 ${PDIR}/*.sh 2> /dev/null || echo -n ''); do
        displayMsg "... $(echo $(basename ${p}) | cut -d'.' -f1)"
        . ${p}

        delayErrors

        echo "Postinstallation of ${p}..."     1>> \
            /sources/buildmgr/logs/install.log 2>> \
            /sources/buildmgr/logs/install.log

        postinst 1>> /sources/buildmgr/logs/install.log \
                 2>> /sources/buildmgr/logs/install.log

        handleErrorsNow "running a post-installation script"
      done

      # Run LFClass interactive configuration
      if [ "${NOT_INTERACTIVE}" == "" ]; then
        displayMsg KEY "Running interactive configuration (if applicable)..."
        (lfclass iconfig) 1>&2

        displayMsg KEY "Changing the password for 'root'..."
        $(which passwd) root 1>&2
      fi
    fi
  fi
}

# Install this script in a way that it is accessible to both host and target OS.
deployScripts() {
  # Decide on a location for the temporary build directory
  local TMP_BUILDDIR="${PWD}/builddir.$$.tmp"

  # Create a list in which order the extra packages will be installed.
  displayMsg "Locating scripts and resolving dependencies..."
  if [ ! -r "${SCRIPTSDIR}" ]; then
    displayMsg ERR "Scripts directory is not accessible."
    exit 1
  fi

  # Select MODE
  if [ "${TMP_CLEANENV}" == "1" ]; then
    local MODE="next"
  else
    local MODE="all"
  fi

  # Execute LFClass
  pushd "${SCRIPTSDIR}/../" &> /dev/null

  rm -rf .excludePkgs.tmp
  for zzz in ${TMP_SKIP}; do
    echo "${zzz}" >> .excludePkgs.tmp
  done

  DEPENDSLIST="$(lfclass dep ${MODE} scripts packages-$(uname -m) \
        .excludePkgs.tmp REQUIRES ${TMP_DEPLEVELS} packs \
        ${TMP_EXTRAPACKS} || echo -n '\fail\')"

  rm -rf .excludePkgs.tmp

  popd &> /dev/null

  # Return on errors
  if [ "${DEPENDSLIST}" == '\fail\' ]; then
    displayMsg ERR "Unable to create a dependency list."
    exit 1
  fi

  # List dependencies, if flag has been set.
  if [ "${TMP_LISTONLY}" == "1" ]; then
    displayMsg KEY "Listing dependencies:"
    local depcount="0"
    for dependency in ${DEPENDSLIST}; do
      local depcount="$(( ${depcount} + 1 ))"
      if [ "${depcount}" -le "9" ]; then
        local prefix="   "
      elif [ "${depcount}" -le "99" ]; then
        local prefix="  "
      elif [ "${depcount}" -le "999" ]; then
        local prefix=" "
      fi

      displayMsg "${prefix}${depcount}. ${dependency}"
      #echo "${dependency}"
    done

    displayMsg "Finished listing dependencies for target."
    exit 0
  fi

  # Load base to check for existing directories
  . "${SCRIPTSDIR}/${TMP_BASESYSTEM}/buildbase.lfs"
  CONTAINS="${TMP_BASESYSTEM}/${CONTAINS}"
  CONTAINS=$(echo ${CONTAINS} | sed "s@ @ ${TMP_BASESYSTEM}/@g")

  # Create list of packages that have been precompiled
  local PRECOMPILED=""
  local TOBECOMPILED=""
  for pack in ${CONTAINS} ${DEPENDSLIST}; do

    # Check if the package is blacklisted.
    local DONTCOPY="0"
    for dontuse in ${TMP_RESUMEX}; do
      if [ "$(basename ${dontuse})" == "$(basename ${pack})" ]; then
        DONTCOPY="1"
      fi
    done

    # Create the list
    if [ -r "$(echo ${PACKSDIR}/${pack}.txz)" ] && [ "${DONTCOPY}" != "1" ]
    then
      local PRECOMPILED="${PRECOMPILED} ${pack}"
    else
      local TOBECOMPILED="${TOBECOMPILED} ${pack}"
    fi

  done

  if [ "${TMP_RESUME}" != "1" ]; then
    local TOBECOMPILED="${CONTAINS} ${DEPENDSLIST}"

    if [ "${PRECOMPILED}" != "" ] && [ "${TMP_SOURCESONLY}" != "1" ]; then
      displayMsg WARN "You are about to build a system from scratch. However,"
      displayMsg WARN "by doing this you will overwrite packages that have been"
      displayMsg WARN "built earlier. Are you sure you want to do this?"
      displayMsg WARN ""
      displayMsg WARN "If you wanted to continue building your system based on"
      displayMsg WARN "the existing packages, you should add '-u' to the"
      displayMsg WARN "arguments."
      queryAbort
    fi

  elif [ ! -r "${PACKSDIR}/${TMP_BASESYSTEM}/toolchain.bak.txz" ]; then

    if [ "${TMP_SECINSTALL}" != "" ]; then
      displayMsg ERR "No toolchain backup was found."
      displayMsg ERR "The '-I' switch requires a precompiled toolchain."
      exit 1
    fi

    # Reset sources list as we may need the source code for already built
    # packages to rebuild the temporary system.
    local TOBECOMPILED="${CONTAINS} ${DEPENDSLIST}"

    displayMsg WARN "No toolchain backup was found. Any precompiled packages"
    displayMsg WARN "that have been found will be used at a later stage, but"
    displayMsg WARN "the temporary system needs to be rebuilt anyway."
    displayMsg WARN ""
    displayMsg WARN "Using precompiled packages while also rebuilding the"
    displayMsg WARN "temporary system may have undesirable effects."
    queryAbort

  fi

  # Download required source code
  displayMsg KEY "Downloading and/or verifying source code..."
  getSources ${TOBECOMPILED}

  # Exit if sourceOnly flag has been set
  if [ "${TMP_SOURCESONLY}" == "1" ]; then
    displayMsg "Finished downloading source code."
    exit 0
  fi

  # Only root can continue.
  if [ "$(whoami)" != "root" ]; then
    displayMsg ERR "You can only build a system as the root user."
    exit 1
  fi

  # Check that the directories required by LFScipt are valid.
  mkdir -p "${PACKSDIR}";
  if [ ! -w "${PACKSDIR}" ]; then
    displayMsg ERR "Package directory is not writable:"
    displayMsg ERR "${PACKSDIR}"
    exit 1
  fi
  mkdir -p "${LOGSDIR}/${TMP_UID}";
  if [ ! -w "${LOGSDIR}/${TMP_UID}" ]; then
    displayMsg ERR "Logs directory is not writable:"
    displayMsg ERR "${LOGSDIR}/${TMP_UID}"
    exit 1
  fi

  # Check for existing files/folders.
  if [ -e "/sources" ]; then
    displayMsg ERR "Directory '/sources' already exists."
    exit 1
  fi
  for dir in "${EXTERNAL_FOLDERS}"; do
    if [ -e "${dir}" ]; then
      displayMsg ERR "Directory '${dir}' already exists."
      exit 1
    fi
  done

  # Since these are random folder names, this *should* never fire.
  if [ -e "${TMP_BUILDDIR}" ]; then
    displayMsg ERR "Build directory already exists."
    exit 1
  fi
  if [ -e "${TMP_BUILDDIR}.2" ]; then
    displayMsg ERR "Secondary build directory already exists."
    exit 1
  fi
  if [ -e "${TMP_SECINSTALL}/sec.$$.tmp" ]; then
    displayMsg ERR "Secondary build directory contents already exist."
    exit 1
  fi

  # Check if the Build User exists.
  local BUEX="$(grep ^${BUILDUSER}: /etc/passwd 2> /dev/null || echo -n '')"
  if [ "${BUEX}" != "" ]; then
    displayMsg ERR "User '${BUILDUSER}' already exists on this system."
    exit 1
  fi

  # Link to target directory if flag has been set
  if [ "${TMP_INSTALL}" != "" ]; then
    ln -s "${TMP_INSTALL}" "${TMP_BUILDDIR}"
  fi

  # Set up secondary installation directory
  if [ "${TMP_SECINSTALL}" != "" ]; then
    ln -s "${TMP_SECINSTALL}" "${TMP_BUILDDIR}.2"

    mkdir "${TMP_BUILDDIR}.2/sec.$$.tmp"
    mkdir "${TMP_BUILDDIR}.2/sec.$$.tmp/tools"
    mkdir -p "${TMP_BUILDDIR}/tools"
    mount --bind "${TMP_BUILDDIR}.2/sec.$$.tmp/tools" "${TMP_BUILDDIR}/tools"
  fi

  # Create build directory with /sources
  mkdir -p "${TMP_BUILDDIR}/sources/src"
  mkdir -p "${TMP_BUILDDIR}/sources/buildmgr"
  mkdir -p "${TMP_BUILDDIR}/sources/buildmgr/packages"
  mkdir -p "${TMP_BUILDDIR}/sources/buildmgr/postinst"
  mkdir -p "${TMP_BUILDDIR}/sources/buildmgr/logs"
  chmod 777 "${TMP_BUILDDIR}/sources/buildmgr/logs"
  chmod a+wt "${TMP_BUILDDIR}/sources"
  chmod a+wt "${TMP_BUILDDIR}/sources/buildmgr"
  ln -sf "${TMP_BUILDDIR}/sources" /
  touch "${TMP_BUILDDIR}/buildmgr.root"

  # Bind mount sources directory (read-only)
  mount --bind             "${SOURCESDIR}" /sources/src
  mount -o remount,ro,bind "${SOURCESDIR}" /sources/src

  # Copy LFClass
  cp -R lfc/build /sources/buildmgr/lfc

  # Save settings
  echo "${DEPENDSLIST}"               > /sources/buildmgr/extrapacks
  echo "${TMP_BUILDDIR}"              > /sources/buildmgr/rootvar
  echo "${TMP_BASESYSTEM}"            > /sources/buildmgr/basesystem
  echo "${TMP_RESUME}"                > /sources/buildmgr/resume
  echo "${TMP_CLEANENV}"              > /sources/buildmgr/cleanenv
  echo "${PACKSDIR}"                  > /sources/buildmgr/packsdir
  echo "${LOGSDIR}/${TMP_UID}"        > /sources/buildmgr/logsdir
  echo "${TMP_AUTOABORT}"             > /sources/buildmgr/autoabort
  echo "${TMP_INSTALL}"               > /sources/buildmgr/installdir
  echo "${TMP_BUILDDIR}.2/sec.$$.tmp" > /sources/buildmgr/secinstalldir

  # Also copy this script into /sources
  if [ -r "lfscript" ]; then
    cp "lfscript" "/sources/buildmgr/buildmgr"
  else
    local INSTALLBIN="/usr/bin"
    cp "${INSTALLBIN}/lfscript" "/sources/buildmgr/buildmgr"
  fi

  # Copy all available build scripts to /sources
  cp -R "${SCRIPTSDIR}" "/sources/buildmgr/scripts"

  # Copy kernel configuration (if available)
  if [ "${TMP_KERNELCONFIG}" != "" ]; then
    cp "${TMP_KERNELCONFIG}" "/sources/buildmgr/kernel.config"
  fi

  # Set first function to start
  if [ "${TMP_RESUME}" == "1" ]; then

    # Make previously compiled packages available
    mount --bind             "${PACKSDIR}" /sources/buildmgr/packages
    mount -o remount,ro,bind "${PACKSDIR}" /sources/buildmgr/packages

    for pack in ${PRECOMPILED}; do
      local distro="$(echo ${pack} | cut -d'/' -f1)"
      mkdir -p "/sources/buildmgr/install-packages/${distro}"
      touch "/sources/buildmgr/install-packages/${pack}.txz"
    done

    displayMsg KEY "Restoring toolchain from backup..."
    if [ -r "${PACKSDIR}/${TMP_BASESYSTEM}/toolchain.bak.txz" ]; then
      cd "${TMP_BUILDDIR}"
      tar --xz -xf "${PACKSDIR}/${TMP_BASESYSTEM}/toolchain.bak.txz"
      cd "${OLDPWD}"
      echo "$(( ${RESUMEBACKUP} - 1 ))" > /sources/buildmgr/currentfunction
    else
      displayMsg KEY WARN "No backup found. Rebuilding the temporary system."
      TMP_BACKUP_TC="1"
      echo "0" > /sources/buildmgr/currentfunction
    fi

  else
    echo "0" > /sources/buildmgr/currentfunction
  fi
  chmod 666 /sources/buildmgr/currentfunction

  # Start buildbase function loop
  local CURRFUNCTIONFILE="/sources/buildmgr/currentfunction"
  while [ "$(( $(cat ${CURRFUNCTIONFILE}) + 1 ))" -le "${LASTFUNCTION}" ]; do
    resumeBaseBuild
  done

  displayMsg KEY "Execution finished."
  cleanUp
}

# Download all required sources
getSources() {
  local MISSINGMD5LIST=()

  for script in $@; do
    WGETLIST=""
    MD5SUMLIST=""
    . "${SCRIPTSDIR}/${script}"

    local FILECOUNTER="0"
    for url in ${WGETLIST}; do
      local FILECOUNTER="$(( ${FILECOUNTER} + 1 ))"
      local THISFILE="$(basename ${url})"
      local THISMD5="$(echo ${MD5SUMLIST} | cut -d' ' -f ${FILECOUNTER})"

      if [ ! -e "${SOURCESDIR}/${THISFILE}" ]; then

        if [ ! -w "${SOURCESDIR}" ]; then
          displayMsg ERR "Sources directory is not writable:"
          displayMsg ERR "${SOURCESDIR}"
          exit 1
        fi

        cd "${SOURCESDIR}"

        local ALTSOURCEDIR="/usr/src"
        if [ -r "${ALTSOURCEDIR}/${THISFILE}" ]; then
          displayMsg "... Copying '${THISFILE}' from a local source."
          cp "${ALTSOURCEDIR}/${THISFILE}" .
          chmod 644 ${THISFILE}
        else
          displayMsg "... Downloading '${THISFILE}'."
          wget ${url} || DLERROR="$?"
        fi

        cd "${OLDPWD}"

        if [ "${DLERROR}" == "127" ]; then
          displayMsg ERR "You do not have the 'wget' utility installed."
          displayMsg ERR "Therefore you should download all the required"
          displayMsg ERR "sources manually... Or install 'wget'."
          exit 1
        elif [ "${DLERROR}" != "" ]; then
          DLERROR=""

          displayMsg WARN "...... Primary URL is down. Trying a mirror."

          # Download from mirror
          cd "${SOURCESDIR}"
          rm -rf ${THISFILE}
          wget http://www.lfscript.org/sources/$(basename ${url}) || DLERR="$?"
          cd "${OLDPWD}"
          if [ "${DLERR}" != "" ]; then
            displayMsg ERR "...... Unable to download file (Code ${DLERR})."
            DLERR=""
          fi
        fi
      fi

      local THISFILE="${SOURCESDIR}/${THISFILE}"

      if [ "${THISMD5}" != "dontverify" ]; then
        local CHECKSUM="$(md5sum ${THISFILE} 2> /dev/null || echo -n '')"
        if [ "${CHECKSUM}" == "" ]; then
          local NALIST="${NALIST} $(basename ${url})"
        elif [ "${CHECKSUM}" != "${THISMD5}  ${THISFILE}" ]; then

          displayMsg "... MD5 checksum failed for '$(basename ${url})'."
          displayMsg WARN "...... Deleting file and trying a mirror."

          # Download from mirror
          cd "${SOURCESDIR}"
          rm -rf ${THISFILE}
          wget http://www.lfscript.org/sources/$(basename ${url}) || DLERR="$?"
          cd "${OLDPWD}"
          if [ "${DLERR}" != "" ]; then
            displayMsg ERR "...... Unable to download file (Code ${DLERR})."
            DLERR=""
          fi

          local CHECKSUM="$(md5sum ${THISFILE} 2> /dev/null || echo -n '')"
          if [ "${CHECKSUM}" == "" ]; then
            local NALIST="${NALIST} $(basename ${url})"
          elif [ "${CHECKSUM}" != "${THISMD5}  ${THISFILE}" ]; then
            local MD5FAILEDLIST="${MD5FAILEDLIST} ${THISFILE}"
            displayMsg ERR "MD5 checksum failed for '$(basename ${url})'."
          else
            displayMsg "... Verified '$(basename ${url})'."
          fi

        else
          displayMsg "... Verified '$(basename ${url})'."
        fi
      else
        if [ ! -r "${THISFILE}" ]; then
          local NALIST="${NALIST} $(basename ${url})"
          displayMsg ERR "The file '$(basename ${url})' is not available."
        else
          if [ "${TMP_LISTMD5}" == "1" ]; then
            displayMsg WARN "... Calculating checksum for '$(basename ${url})'."
            local CHECKSUM="$(md5sum ${THISFILE} 2> /dev/null | cut -d' ' -f1)"
            MISSINGMD5LIST+=("${CHECKSUM}:$(basename ${url})")
          else
            displayMsg WARN "... Didn't verify '$(basename ${url})'."
          fi
        fi
      fi

    done
  done

  if [ "${MD5FAILEDLIST}" != "" ]; then
    displayMsg KEY ERR "The following sources are possibly corrupted (their"
    displayMsg     ERR "checksums are not the same as defined in the scripts):"

    for failed in ${MD5FAILEDLIST}; do
      displayMsg ERR " - ${failed}"
    done

    displayMsg ERR "Please remove these files manually before trying again."
  fi

  if [ "${NALIST}" != "" ]; then
    displayMsg KEY ERR "The following sources are not available:"

    for failed in ${NALIST}; do
      displayMsg ERR " - ${failed}"
    done

    displayMsg ERR "If you have a working network connection, the URL's for"
    displayMsg ERR "these files need to be updated in their scripts."
  fi

  if [ "${TMP_LISTMD5}" == "1" ] && [ "${#MISSINGMD5LIST[@]}" != "0" ]; then
    displayMsg KEY "The following checksums were calculated for files without"
    displayMsg     "checksums defined in their scripts:"

    echo "" 1>&2
    for md5 in ${MISSINGMD5LIST[@]}; do
        echo "${md5:0:32}  ${md5:33}" 1>&2
    done
    echo "" 1>&2

  fi

  if [ "${MD5FAILEDLIST}" != "" ] || [ "${NALIST}" != "" ]; then
    exit 1
  fi
}

# Checks is a filename is an archive that can be extracted.
isArchive() {
  for ext in \\.zip \\.tar\\.bz2 \\.tar\\.gz \\.tar\\.xz \\.tgz \\.tar; do
    if [ "$(echo ${1} | grep ${ext}\$)" ]; then
      echo "true"
      return
    fi
  done
}

# Prepares source code for selected package.
prepareSource() {
  local UNKNOWN_FORMAT="no"

  # First, create a dedicated build directory.
  mkdir builddir
  for url in ${WGETLIST}; do
    ln -s ../src/$(basename ${url}) builddir
  done
  cd builddir

  # For multibuild packages (in Xorg), building occurres a level deeper
  PARENT_DIR="../"
  if [ "${2}" == "multi" ]; then
    mkdir subbuilddir
    cd subbuilddir
    PARENT_DIR="../../"
  fi

  # Extract the primary source archive to a new directory. Archives are
  # extracted in a new directory to guard against zip- and tar BOMBS. 
  mkdir "${1}-extracted"
  cd "${1}-extracted"
  if [ "$(echo ${1} | grep \\.zip\$)" ]; then
    displayMsg "... Extracting source code (ZIP)."
    unzip "${PARENT_DIR}${1}" 1> /dev/null
  elif [ "$(isArchive ${1})" ]; then
    displayMsg "... Extracting source code."
    tar xf "${PARENT_DIR}${1}"
  else
    cd ../
    rm -rf "${1}-extracted"

    if [ "$(echo ${1} | grep \\.img\$)" == "" ]; then
      displayMsg WARN "... Unknown source format. Not extracting '${1}'"
    fi

    local UNKNOWN_FORMAT="yes"
  fi

  # This next part moves a folder back if the archive did not EXPLODE.
  if [ "${UNKNOWN_FORMAT}" != "yes" ]; then
    local  DIRCOUNT="$(ls -d */ 2> /dev/null | grep -c  '/' || echo -n '')"
    local FILECOUNT="$(ls -dp * 2> /dev/null | grep -cv '/' || echo -n '')"
    if [ "${DIRCOUNT}" == "1" ] && [ "${FILECOUNT}" == "0" ]; then
      mv "$(ls -d */)" ../
      cd ../
      rm -rf "${1}-extracted"
      cd "$(ls -d */)"
    fi
  fi

  # If we're building a kernel, copy or create the configuration
  if [ "$(basename ${SELECTEDPACKAGE})" == "kernel" ] ||
     [ $(echo "${TAGS}" | grep "\bkernel\b" || echo -n '') ]; then
    displayMsg "...... Preparing kernel source."
    make mrproper

    if [ -r "/sources/buildmgr/kernel.config" ]; then
      cp /sources/buildmgr/kernel.config .config
    else
      displayMsg WARN "...... No custom kernel configuration found."
      displayMsg WARN "...... Running 'make defconfig'."
      make defconfig &> /dev/null
    fi

    # Uprade the configuration to work with the current kernel
    yes "" | make oldconfig &> /dev/null
  fi
}

# Function that loads a script, sets up its source code and then executes it.
BUILD() {
  # Utilise all CPU cores
  local BUILDMGR_MAKEFLAGS="-j $(cat /proc/cpuinfo | grep processor | wc -l)"
  export MAKEFLAGS="${BUILDMGR_MAKEFLAGS}"

  # Load and run any distribution specific initialization operations
  if [ -r "/sources/buildmgr/scripts/extend.conf" ]; then
    . /sources/buildmgr/scripts/extend.conf
  fi

  # Reset package variables
  WGETLIST=""
  MD5SUMLIST=""
  POSTINST=""
  TAGS=""

  PREINST_DONE=""

  # If an ambiguous name has been set (without a slash), assume the package is
  # from the base system.
  if [ "$(echo ${1} | grep '/' 2> /dev/null || echo -n '')" == "" ]; then
    local SELECTEDPACKAGE="${BASESYSTEM}/${1}"
    local REPOFOLDER="${BASESYSTEM}"
  else
    local SELECTEDPACKAGE="${1}"
    local REPOFOLDER="$(echo ${1} | cut -d'/' -f1)"
  fi

  # If wanted, and available. Don't build current package, but use a TGZ.
  local RESUMELFS="$(cat /sources/buildmgr/resume)"
  if [ "${RESUMELFS}" == "1" ] && [ -e /buildmgr.root ]; then
    if [ -r "/sources/buildmgr/install-packages/${SELECTEDPACKAGE}.txz" ]; then

      displayMsg KEY "Selected '${SELECTEDPACKAGE}'..."
      displayMsg "... Precompiled package found."
      installPkgBuilt "/sources/buildmgr/packages/${SELECTEDPACKAGE}.txz"

      return
    fi
  fi

  # Load build script
  cd "/sources"
  local SCRIPT_SRC="/sources/buildmgr/scripts/${SELECTEDPACKAGE}"
  . ${SCRIPT_SRC}

  # Exit here, if the script only lists dependencies
  if [ $(echo "${TAGS}" | grep "\bgroup\b" || echo -n '') ]; then
    return
  fi

  displayMsg KEY "Selected '${SELECTEDPACKAGE}'..."

  # Disable MAKEFLAGS if package supports only one core to build it
  if [ "$(cat ${SCRIPT_SRC} | grep '\-j1')" != "" ] && 
     [ "${MAKEFLAGS}" == "${BUILDMGR_MAKEFLAGS}" ]; then
    displayMsg "... Disabling multi-core compilation for this package."
    unset MAKEFLAGS
  fi

  # Start building
  if [ ! -e "/buildmgr.root" ]; then

    # Extract source code
    prepareSource "$(basename $(echo ${WGETLIST} | cut -d' ' -f1))"

    displayMsg "... Building a temporary version of this software."
    local LOGNAME="$(basename ${SELECTEDPACKAGE}).prep"

    delayErrors
    preparation &> "/sources/buildmgr/logs/${LOGNAME}"
    handleErrorsNow "building the temporary package"

    # Cleanup
    cd "/sources"
    rm -rf builddir

  else

    # Run pre-installation on precompiled package
    PREINST_DONE="true"
    if [ $(echo "${TAGS}" | grep "\bpreinst\b" || echo -n '') ]; then
      displayMsg "... Running the pre-installation script."
      local LOGNAMEPREINST="$(basename ${SELECTEDPACKAGE}).preinst"

      delayErrors

      echo "Preinstallation of ${SELECTEDPACKAGE}..." 1>> \
            /sources/buildmgr/logs/install.log        2>> \
            /sources/buildmgr/logs/install.log

      preinst 1>> /sources/buildmgr/logs/install.log \
              2>> /sources/buildmgr/logs/install.log

      handleErrorsNow "running the pre-installation script for new software"
    fi

    if [ $(echo "${TAGS}" | grep "\bmulti\b") ]; then

      mkdir parts

      for urlx in ${WGETLIST}; do

        local SUBPACKAGE="$(basename $urlx)"

        if [ "$(isArchive ${SUBPACKAGE})" ]; then

          displayMsg ". Selected part '${SUBPACKAGE}'."

          # Extract source code
          prepareSource "${SUBPACKAGE}" multi
          local LOGNAMEI="$(basename ${SUBPACKAGE}).inst"

          buildPackage

          # Cleanup
          local PKGNAME="$(basename ${SELECTEDPACKAGE})"
          mv "/sources/buildmgr/newpackages/${REPOFOLDER}/${PKGNAME}.txz" \
             "/sources/parts/${SUBPACKAGE}.txz"
          cd /sources
          rm -rf builddir

        fi

      done

      # Combine archives into a single package
      displayMsg ". Combining packages in '${SELECTEDPACKAGE}'."
      cd parts
      for arch in $(ls -1 *.txz); do
        tar xf ${arch}
        cd "${PKGNAME}"
        tar xf pkgroot.tar --dereference
        cd ../
      done
      cd "${PKGNAME}"
      rm -rf MD5SUMS
      tar cf pkgroot.tar pkgroot --hard-dereference
      rm -rf pkgroot
      md5sum * > MD5SUMS
      cd ../
      tar --xz -cf /sources/buildmgr/newpackages/${REPOFOLDER}/${PKGNAME}.txz \
            ${PKGNAME}
      cd ../
      rm -rf parts

    else

      # Extract source code
      if [ "${WGETLIST}" != "" ]; then
        prepareSource "$(basename $(echo ${WGETLIST} | cut -d' ' -f1))"
      else
        mkdir builddir
        cd builddir
      fi

      local LOGNAMEI="$(basename ${SELECTEDPACKAGE}).inst"

      buildPackage

      # Cleanup
      cd "/sources"
      rm -rf builddir

    fi

    # Restore environment for next package if we're building 'clean'.
    if [ "$(cat /sources/buildmgr/cleanenv)" == "1" ]; then
      touch /sources/buildmgr/cleanexit
      manualAbort
    fi

  fi
}

# Builds the package
buildPackage() {
  # Create a fakeroot
  local FAKEROOT="/sources/buildmgr/pkgroot"
  mkdir -p ${FAKEROOT}

  # (*) Create a few directories expected by scripts
  # NOTE: *NOT* to ${FAKEROOT}; Or they are not deleted if empty
  mkdir -p /etc/{profile.d,skel}

  displayMsg "... Preparing directory structure."



    ###########################################
    ### CREATE DIRECTORY AND SYMLINK ARRAYS ###
    ###########################################

    # Create an array of directories
    unset DIRECTORIES i
    while IFS= read -r -d '' found; do
        DIRECTORIES[i++]="${found}"
    done < <(find / -path '/tools' -prune -o -path '/sources' -prune -o \
            -path '/dev' -prune -o -path '/proc' -prune -o -path '/sys' -prune \
            -o -type d -printf %G:%U\\0%m\\0%p\\0)

    # Create an array of directory symlinks
    unset SYMLINKS i
    while IFS= read -r -d '' found; do
        [ "${found}" == "/" ] && continue
        local ISDIRLINK=$(pushd "${found}" 2> /dev/null || echo -n '')
        if [ "${ISDIRLINK}" != "" ]; then
            SYMLINKS[i++]="${found}"
        fi
    done < <(find / -path '/tools' -prune -o -path '/sources' -prune -o \
            -path '/dev' -prune -o -path '/proc' -prune -o -path '/sys' -prune \
            -o -type l -print0)

    ######################################
    ### CLONE ROOT DIRECTORY STRUCTURE ###
    ######################################

    # Clone directories
    for (( i=0; i < ${#DIRECTORIES[@]}; )); do
        local OWNER="${DIRECTORIES[i++]}"
        local MODE="${DIRECTORIES[i++]}"
        local DIRNAME="${DIRECTORIES[i++]}"

        [ "${DIRNAME}" == "/" ] && continue

        mkdir --mode=${MODE} "${FAKEROOT}${DIRNAME}"
    done

    # Clone directory symlinks
    for found in "${SYMLINKS[@]}"; do
        local LINKTO=$(readlink "${found}")

        # Adjust absolute links
        if [ "${LINKTO:0:1}" == "/" ]; then
            local LINKTO="${FAKEROOT}${LINKTO}"
        fi

        ln -sv "${LINKTO}" "${FAKEROOT}${found}"
    done



  # Set message strings
  if [ "$(basename ${SELECTEDPACKAGE})" == "buildiso" ]; then
    displayMsg "... Compressing the system and building an ISO image."
  else
    displayMsg "... Building the software."
  fi

  # Install the package
  local LOGFILE="/sources/buildmgr/logs/${LOGNAMEI}"

  delayErrors
  installation &> ${LOGFILE}
  handleErrorsNow "building the software"

  # Strip binaries of their debugging symbols
  /tools/bin/find ${FAKEROOT}/{,usr/}{bin,lib,sbin} -type f \
    -exec /tools/bin/strip --strip-debug '{}' ';' &> /dev/null || echo -n ''

  # (*) Remove /usr/share/info/dir (it is recreated in texinfo postinst)
  rm -rf {,${FAKEROOT}}/usr/share/info/dir



    ###########################################
    ### CLEAN UP CLONED DIRECTORY STRUCTURE ###
    ###########################################

    # Remove superfluous directory symlinks
    for found in "${SYMLINKS[@]}"; do
        rm -rf "${FAKEROOT}${found}"
    done

    # Remove superfluous directories
    for (( i="${#DIRECTORIES[@]} - 1"; i > -1; )); do
        local DIRNAME="${DIRECTORIES[i--]}"
        local MODE="${DIRECTORIES[i--]}"
        local OWNER="${DIRECTORIES[i--]}"

        [ "${DIRNAME}" == "/" ] && continue

        cd "${FAKEROOT}${DIRNAME}" &> /dev/null &&
        if [ "$(ls -A)" == "" ]; then
            cd ../
            rmdir "${FAKEROOT}${DIRNAME}"
        fi
    done

    ##################################
    ### VERIFY DIRECTORY OWNERSHIP ###
    ##################################

    cd "${FAKEROOT}"
    while IFS= read -r -d '' found; do
        [ "${found}" == "." ] && continue

        local OWNER=$(stat --format=%u:%g "${found}")
        if [ "${OWNER}" != "0:0" ]; then
            local CDIR="${found:1}"
            displayMsg WARN "...... Directory not owned by root: '${CDIR}'"
        fi
    done < <(find . -type d -print0)



  # Create a package

  # Verify that there is something to package
  cd "${FAKEROOT}"
  if [ "$(ls -A)" == "" ]; then
    local NOPACKAGE="1"
  fi
  cd ../

  local PKGNAME="$(basename ${SELECTEDPACKAGE})"

  if [ ! "${NOPACKAGE}" ]; then

    displayMsg "... Creating package archive."
    mkdir -p "temp.txz/${PKGNAME}"
    tar cf "temp.txz/${PKGNAME}/pkgroot.tar" pkgroot --hard-dereference
    cp "${SCRIPT_SRC}" "temp.txz/${PKGNAME}/buildscript"
    cd "temp.txz/${PKGNAME}"
    md5sum * > MD5SUMS
    cd ../
    tar --xz -cf "${PKGNAME}.txz" "${PKGNAME}"
    mkdir -p "../newpackages/${REPOFOLDER}"
    mv "${PKGNAME}.txz" "../newpackages/${REPOFOLDER}"

    # Remove the fakeroot
    cd "${FAKEROOT}/../"
    rm -rf ${FAKEROOT}
    rm -rf temp.txz

    # Install the package
    installPkgBuilt "/sources/buildmgr/newpackages/${REPOFOLDER}/${PKGNAME}.txz"

  else

    displayMsg WARN "There were no files found to package."

  fi
}

# Install a pre-compiled package
installPkgBuilt() {
  local PKG="${1}"

  # Prepare
  local TMPDIR="/tmp/install.$$.tmp" #TODO: Move to PWD
  if [ -e ${TMPDIR} ]; then
    displayMsg ERR "Temporary installation directory exists."
    queryAbort
  fi
  mkdir ${TMPDIR}
  cd ${TMPDIR}
  tar xf "${PKG}"
  cd "$(ls -d */)"

  # Check package checksums
  md5sum -c MD5SUMS &> /dev/null; MD5ERR="$?"
  if [ "${MD5ERR}" != "0" ]; then
    displayMsg ERR "The contents of the package archive are corrupted."
    queryAbort
  fi

  # Load build script
  . buildscript

  # Run pre-installation on precompiled package
  if [ $(echo "${TAGS}" | grep "\bpreinst\b" || echo -n '') ] &&
      [ "${PREINST_DONE}" == "" ]; then
      displayMsg "... Running the pre-installation script."
      delayErrors

      echo "Preinstallation of ${PKG}..."      1>> \
            /sources/buildmgr/logs/install.log 2>> \
            /sources/buildmgr/logs/install.log

      preinst 1>> /sources/buildmgr/logs/install.log \
              2>> /sources/buildmgr/logs/install.log
      handleErrorsNow "running the pre-installation script"
  fi

  # Install files
  displayMsg "... Installing to system."
  ln -s / pkgroot
  tar xf pkgroot.tar --dereference

#  # Remember the order in which the packages are installed
#  echo "${PKG}" >> /sources/buildmgr/packageorder

  # Update linker cache, if 'ldconfig' is available
  ldconfig &> /dev/null || echo -n ''

  # Reload profile if neccessary and available
  local PFL="$(tar tf pkgroot.tar          | \
                 grep '^pkgroot/etc/profile' \
                    || echo -n '')"
  if [ "${PFL}" ]; then
      displayMsg "... Reloading system profile."
      . /etc/profile
  fi

  # Allow the script to check if we're installing the system
  if [ "$(cat /sources/buildmgr/installdir)" != "" ]; then
      export LFSCRIPT_INSTALL="true"
  fi

  # Post installation script
  if [ "$(echo ${POSTINST} | grep '^now\b')" != "" ]; then
    if [ -r "/sources/buildmgr/scripts/install.conf" ]; then
      . /sources/buildmgr/scripts/install.conf
    fi

    displayMsg "... Running the post-installation script."
    delayErrors

    echo "Postinstallation of ${PKG}..."   1>> \
        /sources/buildmgr/logs/install.log 2>> \
        /sources/buildmgr/logs/install.log

    postinst | tee -a /sources/buildmgr/logs/install.log

    handleErrorsNow "running the post-installation script"
  elif [ "${POSTINST}" ]; then
    cp buildscript /sources/buildmgr/postinst/$(basename ${PKG}).sh
  fi

  # Cleanup
  cd /
  rm -rf ${TMPDIR}
}

# Select the base system, if exactly one is available
findBasesystem() {
  local STMS="$(ls -1 ${SCRIPTSDIR}/*/buildbase.lfs 2> /dev/null || echo -n '')"
  local BASECOUNT="0"

  for basesystem in ${STMS}; do
    BASECOUNT="$(( ${BASECOUNT} + 1 ))"
    if [ "2" -le "${BASECOUNT}" ]; then
      displayMsg ERR "Multiple base systems available. Use -b <system>, not -B."
      exit 1
    else
      TMP_BASESYSTEM=$(echo "${STMS}" | sed \
                        "s@${SCRIPTSDIR}/@@;s@/buildbase.lfs@@")
    fi
  done

  if [ "${BASECOUNT}" == "0" ]; then
    displayMsg ERR "No base system scripts available."
    exit 1
  fi
}

# Try to make sure that LFScript can be run in this system
verifyEnvironment() {

  # Verify that enough memory is available. Builds have been successfull with
  # 768 MiB of RAM, but it is better to be safe and always warn below 1 GiB.
  if [ "${TMP_MEMTEST}" == "1" ]; then
    local MEMREQ_MB="950" # 1 GiB, with some slack

    local MEMSIZE_KB="$(grep MemTotal /proc/meminfo | awk '{print $2}')"
    local MEMSIZE_MB="$((${MEMSIZE_KB} / 1024))"

    if [ "${MEMSIZE_MB}" -lt "${MEMREQ_MB}" ]; then
      displayMsg ERR "The system memory size (as reported by /proc/meminfo) is"
      displayMsg ERR "${MEMSIZE_MB} MiB. This is less than the recommended"
      displayMsg ERR "minimum of 1 GiB and *could* cause build failures in"
      displayMsg ERR "large software (for example in the temporary build of"
      displayMsg ERR "GCC) if it is significantly less."
      displayMsg ERR ""
      displayMsg ERR "Enough SWAP space may (or may not) solve these problems,"
      displayMsg ERR "but can slow down the build process."
      displayMsg ERR ""
      displayMsg ERR "If you want to build your system anyway; Use the -M"
      displayMsg ERR "switch on LFScript to tell it to ignore memory size."
      exit 1
    fi
  fi

  # Note, we can not test all host requirements of LFS with 100% certainty
  # because many systems implement the way version numbers are printed
  # differently and any required wrapper scripts could be named anyting.
  # Therefore, the rest of this function only performs limited tests which
  # should work on 99.9% of the systems out there.
  PREREQ_FAIL="0"

  # Ability to compile
  echo 'main(){}' > dummy.c && gcc -o dummy dummy.c
  if [ ! -x dummy ]; then
    PREREQ_FAIL="1"
  fi
  rm -f dummy.c dummy

  # /bin/sh -> bash
  if [ "$(basename $(readlink -f /bin/sh))" != "bash" ]; then
    PREREQ_FAIL="1"
  fi

  if [ "${PREREQ_FAIL}" != "0" ]; then
      displayMsg ERR "This system does not meet the LFS host system"
      displayMsg ERR "requirements. Please read the Linux From Scratch preface"
      displayMsg ERR "(section 'Host System Requirements') to make your system"
      displayMsg ERR "compatible."
      displayMsg ERR ""
      displayMsg ERR "Note that when you no longer receive this message, it"
      displayMsg ERR "does not necessarily mean that your system now does meet"
      displayMsg ERR "the requirements. LFScript only tests a couple of very"
      displayMsg ERR "basic aspects of your system."
      exit 1
  fi
}

# Make sure there are no spaces in the current directory
if [ "$(echo ${PWD} | grep ' ' || echo -n '')" != "" ]; then
  displayMsg ERR "LFScript can't be run in a directory which contains spaces."
  exit 1
fi

# Default values for key folders; Preferably, these should NOT be changed.
  STARTDIR="${PWD}"
SCRIPTSDIR="${PWD}/scripts"
  PACKSDIR="${PWD}/packages-$(uname -m)"
SOURCESDIR="${PWD}/sources"
   LOGSDIR="${PWD}/logs"

if [ "${1}" == "--resumebasebuild" ]; then
  resumeBaseBuild
else

  TMP_UID="$(date +%Y-%m-%d_%H:%M:%S)"

  # Clear switch variables, so that there can be no outside interference
  TMP_AUTOABORT="0"
  TMP_LISTONLY="0"
  TMP_SOURCESONLY="0"
  TMP_LISTMD5="0"
  TMP_RESUME="0"
  TMP_BACKUP_TC="1"
  TMP_INSTALL=""
  TMP_SECINSTALL=""
  TMP_CLEANENV="0"
  TMP_BASESYSTEM=""
  TMP_KERNELCONFIG=""
  TMP_MEMTEST="1"
  TMP_EXTRAPACKS=""
  TMP_DEPLEVELS="RECOMMENDS"
  TMP_RESUMEX=""
  TMP_SKIP=""

  topBanner

  while getopts 's:i:I:ALMSHBb:k:x:uU:Cr' OPTION 2> /dev/null; do
    case ${OPTION} in
      i)
         TMP_INSTALL="${OPTARG}"
         if [ ! -d "${TMP_INSTALL}" ]; then
           displayMsg ERR "Target directory does not exist (-i)."
           exit 1
         fi

         mountpoint ${TMP_INSTALL} &> /dev/null || {
           displayMsg ERR "Target directory is not a mountpoint (-i)."
           exit 1            
         }
         ;;
      I)
         TMP_SECINSTALL="${OPTARG}"
         if [ ! -d "${TMP_SECINSTALL}" ]; then
           displayMsg ERR "Target temporary directory does not exist (-I)."
           exit 1
         fi
         ;;
      A)
         TMP_AUTOABORT="1"
         ;;
      L)
         TMP_LISTONLY="1"
         ;;
      S)
         TMP_SOURCESONLY="1"
         ;;
      H)
         TMP_SOURCESONLY="1"
         TMP_LISTMD5="1"
         ;;
      u)
         TMP_BACKUP_TC="0"
         TMP_RESUME="1"
         ;;
      b)
         TMP_BASESYSTEM="${OPTARG}"
         if [ ! -r "${SCRIPTSDIR}/${TMP_BASESYSTEM}/buildbase.lfs" ]; then
           displayMsg ERR "Base system script not found or unreadable (-b)."
           exit 1
         fi
         ;;
      B)
         findBasesystem
         ;;
      k)
         TMP_KERNELCONFIG="${OPTARG}"
         if [ ! -r "${TMP_KERNELCONFIG}" ]; then
           displayMsg ERR "Kernel configuration not found or unreadable (-k)."
           exit 1
         fi
         ;;
      C)
         TMP_BACKUP_TC="0"
         TMP_RESUME="1"
         TMP_CLEANENV="1"
         ;;
      r)
         TMP_DEPLEVELS=""
         ;;
      s)
         TMP_SKIP="${OPTARG}"
         ;;
      x)
         TMP_EXTRAPACKS="${OPTARG}"
         ;;
      U)
         TMP_BACKUP_TC="0"
         TMP_RESUME="1"
         TMP_RESUMEX="${OPTARG}"
         ;;
      M)
         TMP_MEMTEST="0"
         ;;
      ?)
         displayMsg WARN "Unknown options set."
         displayMsg WARN "Read the manual for usage instructions."
         exit 1
         ;;
    esac
  done

  if [ "${TMP_CLEANENV}" == "1" ] && [ "${TMP_INSTALL}" != "" ]; then
    displayMsg ERR "The '-C' and '-i' switches are not compatible with each"
    displayMsg ERR "other."
    exit 1
  fi

  if [ "${TMP_CLEANENV}" == "1" ] && [ "${TMP_RESUMEX}" != "" ]; then
    displayMsg ERR "The '-C' and '-U' switches are not compatible with each"
    displayMsg ERR "other."
    exit 1
  fi

  if [ "${TMP_CLEANENV}" == "1" ] && [ "${TMP_SECINSTALL}" != "" ]; then
    displayMsg ERR "The '-C' and '-I' switches are not compatible with each"
    displayMsg ERR "other."
    exit 1
  fi

#  if [ "${TMP_SECINSTALL}" == "" ] &&
#     [ "${TMP_RESUMEX}" == "" ] &&
#     [ "${TMP_INSTALL}" == "" ]; then
#    displayMsg KEY WARN "Consider using the '-C' switch to reset the environment"
#    displayMsg WARN "after the compilation of each software package."
#    displayMsg WARN "This ensures that software is not accidentally linked"
#    displayMsg WARN "against software that is not a direct requirement."
#    displayMsg WARN ""
#  fi

  if [ "${TMP_RESUME}" != "1" ] && [ "${TMP_SECINSTALL}" != "" ]; then
    displayMsg ERR "The '-I' switch requires that at least the toolchain has"
    displayMsg ERR "already been compiled. Add the '-u' switch."
    exit 1
  fi

  if [ "${TMP_BASESYSTEM}" != "" ]; then
    verifyEnvironment
    deployScripts
  else
    displayMsg ERR "You should at least specify a base system."
    displayMsg ERR "Read the manual for usage instructions."
  fi
fi

